#!/home/badassgirl/pymupdf_venv/bin/python
import os
import fitz

class ParseTableFromPDF():

  def print_error(self, line):
    print("Error: " + line)
    exit()

  def print_warning(self, line):
    print("Warning: " + line)

  def update_table_name(self, line):
    #Extract table name from line
    #Figure format - Figure xx: xxxxxx
    #If it is a new table, create a new file.
    #Otherwise add lines in the existed files. 
    table_name = line.strip(" \n").split(":")[-1].strip("' ").replace(" ", "_").replace("â€“", "_").replace(",","_").replace("/", "")
    start_new_table = 0
    if (table_name != self.table_name):
      self.table_name = table_name
      #create a new file
      self.csv_write_mode = "w"
      self.table_head = []
      self.head_column_cnt = 0
      self.table_rows = []
      self.column_per_row = 0
    else:
      self.csv_write_mode = "a"
      self.table_rows = []

  #Convert row of table to string
  def table_row_to_csv_line(self, row):
    s = "" 
    for col in row:
      s += col + ", "
    s = s.replace("\n", " ")
    s = s.strip(", ")+"\n"
    return s

  #rows: all the rows in this table
  def process_table(self, rows):
    table_head = []
    #row[0] is the head of the table, count only if col is not None
    for col in rows[0]:
      if col != "" and col != None:
        table_head.append(col)
    #Report warning if the table exists and the column count of the head does not match the previous one.
    if self.head_column_cnt != 0 and self.head_column_cnt != len(table_head):
        self.print_warning("{} head column cnt - previous: {}, current: {}".format(self.table_name, self.head_column_cnt, len(table_head)))
    #Update column count of table head and rows
    else:
      self.table_head = table_head
      self.head_column_cnt = len(table_head)
      self.column_per_row = self.head_column_cnt

    for i in range(1, len(rows)):
      row = rows[i]
      table_content = []
      col_cnt = 0
      for col in row:
        col_cnt += 1
        if col != None:
          #Description format - xxx: xxxxxxxx Extract the left part
          if ":" in col and col_cnt != 1:
            col = col.split(":")[0]
          #table content is per row of the table
          table_content.append(col)
      #report warning if the column of each row does not match the initial setting
      if self.column_per_row != len(table_content):
          self.print_warning("{} row {} content column cnt - previous: {}, current: {}".format(self.table_name, (i+1), self.column_per_row, len(table_content)))
          s = self.table_row_to_csv_line(table_content)
          self.print_warning("{} will be discarded".format(s.strip("\n")))
      else:
        if table_content[0] != "":
          self.table_rows.append(table_content)

    #generate csv file
    csv_file_name = self.table_name + ".csv"
    fname = os.path.join(self.csv_folder, csv_file_name)
    f = open(fname, self.csv_write_mode)
    if self.csv_write_mode == "w":
      f.writelines("//This file is automatically generated by extract_table.py\n")
      f.writelines("//Following contents are extracted from page {}\n".format(self.current_page))
      s = self.table_row_to_csv_line(self.table_head)
      f.writelines(s)
    for row in self.table_rows:
      s = self.table_row_to_csv_line(row)
      f.writelines(s)
    f.close()
    print ("CSV file output at {}".format(fname))

  def get_page(self):
    for r in self.page_ranges:
      r_min = r[0]
      r_max = r[1]
      for i in range(r[0], r[1]+1):
        self.pages_to_detect.append(i)

  def extract_table(self):
    self.get_page()
    table_dict = {}
    sub_tbl_dict = {}
    for page in self.pages:
      self.current_page += 1
      #Only check the pages to be detected --> self.pages_to_detect
      if self.current_page in self.pages_to_detect:
        #titles -> table name extracted from Figure xxx
        titles = []
        #table_dict - key: table count (int), value: table object
        #Search for tables. List of tables.
        tbl = page.find_tables()
        if len(tbl.tables) != 0:
          print("Find table on page {}".format(self.current_page))
          txt = page.get_text("text")
          tbl_cnt = 1
          #title_pos_dict -- key: vertical position of the table title, value: table count
          title_pos_dict = {}
          for line in txt.split("\n"):
            #Count number of table title in the page. Record the vertical position of it.
            if line.strip(" \n").startswith("Figure ") and ":" in line and "Figure 101" not in line:
              titles.append(line)
              rect = page.search_for(line)
              title_pos_dict[rect[0][1]] = tbl_cnt
              tbl_cnt += 1
          #Since there are sub-tables embedded in tables, filter the subtitle by following procedures.
          #If there are multiple tables, check the vertical position of the table vs table title. 
          for obj in tbl.tables:
            a = obj.bbox[1]
            check_done = 0
            for pos in title_pos_dict.keys():
              if check_done == 0 and pos < a:
                v = title_pos_dict[pos]
                if v not in table_dict.keys():
                  table_dict[v] = obj
                  check_done = 1
            #if check_done == 0:
            #  self.sub_tbl_cnt += 1
            #  sub_tbl_dict[self.sub_tbl_cnt] = obj


        if len(titles) != len(table_dict.keys()):
          if len(titles) > len(table_dict.keys()):
            self.print_error("Table Count Mismatch! {} Title != {} Table".format(len(titles), len(table_dict.keys())))
          else:
            titles.append("dummy")
        else:
          for i in range(0, len(titles)):
            self.update_table_name(titles[i])
            self.process_table(table_dict[i+1].extract())
    #for key in sub_tbl_dict.keys():
    #  self.update_table_name("sub_table_{}".format(key))
    #  self.process_table(sub_tbl_dict[key].extract())


  def __init__(self, fpath):
    if not os.path.isfile(fpath):
      self.print_error("{} does not exist. Please check file path.".format(fpath))
    self.csv_folder = "../doc/csv"
    self.pages = fitz.open(fpath)
    self.page_ranges = [[61, 61]]
    self.pages_to_detect = []
    self.current_page = 0
    #self.pages_to_detect = [74]
    self.table_name = ""
    self.table_head = []
    self.head_column_cnt = 0
    self.table_rows = []
    self.column_per_row = 0
    self.csv_write_mode = "w"
    s = ""
    for p in self.pages_to_detect:
      s += "{}, ".format(p)
    s = s.strip(", ")
    print("Search tables on page {}".format(s))
    os.system("rm ../doc/csv/*.csv")
    self.sub_tbl_cnt = 0

nvme_base_spec = ParseTableFromPDF("../doc/nvme_protocol/NVM-Express-NVM-Command-Set-Specification-Revision-1.1-2024.08.05-Ratified.pdf")
nvme_base_spec.extract_table()
